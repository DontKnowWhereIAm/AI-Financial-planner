# Let's inspect the uploaded sample and generate the requested CSV (expenses organized month-by-month).
import pandas as pd, re, os
from pathlib import Path
from dateutil import parser as dateparser
from datetime import datetime
import numpy as np

path = Path(r"C:\Users\ssvas\Downloads\bank_statement_ex.xlsx")

assert path.exists(), "Sample file not found at Downloads/bank_statement_ex.xlsx"

def normalize_columns(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    df.columns = [re.sub(r"\s+", " ", str(c)).strip().lower() for c in df.columns]
    return df

DATE_CANDIDATES = [
    "date","post date","posting date","transaction date","trans date",
    "posted date","value date","statement date"
]
DESC_CANDIDATES = [
    "description","details","detail","memo","narrative","payee","merchant","transaction"
]
AMOUNT_CANDIDATES = ["amount","amt","transaction amount","value","amount ($)","amount usd"]
DEBIT_CANDIDATES  = ["debit","withdrawal","withdrawals","charges","spend","expense","debits"]
CREDIT_CANDIDATES = ["credit","deposit","deposits","payments","credits","income"]

def read_xl(path: Path) -> pd.DataFrame:
    # read first sheet by default
    df = pd.read_excel(path)
    return normalize_columns(df)

def find_col(df, candidates):
    cols = list(df.columns)
    for c in candidates:
        if c in cols:
            return c
    for c in candidates:
        for col in cols:
            if c in col:
                return col
    return None

def coerce_amount(x):
    if pd.isna(x): return None
    s = str(x).strip()
    if s == "": return None
    neg = False
    if s.startswith("(") and s.endswith(")"):
        neg = True
        s = s[1:-1]
    s = re.sub(r"[^0-9.\-]", "", s)
    if s.count("-") > 1:
        s = s.replace("-", "")
        s = "-" + s
    try:
        val = float(s)
        return -abs(val) if neg else val
    except:
        return None

def coerce_date(x):
    if pd.isna(x): return None
    # If it's already a datetime or excel serial date, pandas will handle
    try:
        return pd.to_datetime(x, errors='coerce')
    except Exception:
        pass
    s = str(x).strip()
    if not s: return None
    try:
        return pd.to_datetime(dateparser.parse(s, dayfirst=False, yearfirst=False))
    except Exception:
        return None

df_raw = read_xl(path)

# Detect key columns
date_col   = find_col(df_raw, DATE_CANDIDATES)
desc_col   = find_col(df_raw, DESC_CANDIDATES)
amount_col = find_col(df_raw, AMOUNT_CANDIDATES)
debit_col  = find_col(df_raw, DEBIT_CANDIDATES)
credit_col = find_col(df_raw, CREDIT_CANDIDATES)

detected = {
    "date_col": date_col,
    "desc_col": desc_col,
    "amount_col": amount_col,
    "debit_col": debit_col,
    "credit_col": credit_col,
    "all_columns": list(df_raw.columns),
    "n_rows": len(df_raw),
}

# Build transactions
def build_signed_amount(df: pd.DataFrame, amount_col: str | None, debit_col: str | None, credit_col: str | None) -> pd.Series:
    if amount_col:
        return df[amount_col].map(coerce_amount)
    debit = df[debit_col].map(coerce_amount) if debit_col else None
    credit = df[credit_col].map(coerce_amount) if credit_col else None
    if debit is not None and credit is not None:
        return (credit.fillna(0) - debit.fillna(0))
    if debit is not None:
        return -debit
    if credit is not None:
        return credit
    raise ValueError("Could not determine an amount source. No amount/debit/credit column detected.")

# Construct normalized DataFrame
trans = pd.DataFrame()
if date_col is None or desc_col is None or (amount_col is None and debit_col is None and credit_col is None):
    summary = pd.DataFrame([detected])
    print(df_raw.head())
    raise SystemExit("Could not detect required columns from sample; shared a detection summary to review.")
else:
    trans["Date"] = df_raw[date_col].map(coerce_date)
    trans["Description"] = df_raw[desc_col].astype(str).str.replace(r"\s+", " ", regex=True).str.strip()
    trans["Amount"] = build_signed_amount(df_raw, amount_col, debit_col, credit_col)
    # Drop rows with no date or amount
    trans = trans.dropna(subset=["Date","Amount"])

# Determine which sign represents expenses
neg_ct = int((trans["Amount"] < 0).sum())
pos_ct = int((trans["Amount"] > 0).sum())

if neg_ct > 0:
    expenses = trans[trans["Amount"] < 0].copy()
    # keep negative sign convention
elif pos_ct > 0:
    expenses = trans[trans["Amount"] > 0].copy()
    expenses["Amount"] = -expenses["Amount"].abs()
else:
    expenses = trans.iloc[0:0].copy()

# Add Month and sort
if not expenses.empty:
    expenses["Month"] = expenses["Date"].dt.to_period("M").astype(str)
    expenses_out = expenses.sort_values(["Month","Date","Description"])[["Month","Date","Description","Amount"]]
else:
    expenses_out = expenses

# Save output
out_path = path.with_name(path.stem + "_expenses_by_month.csv")
expenses_out.to_csv(out_path, index=False)

# Prepare quick diagnostics for the user
diag = pd.DataFrame([{
    "rows_in_sample": int(len(df_raw)),
    "rows_parsed": int(len(trans)),
    "neg_amount_rows": neg_ct,
    "pos_amount_rows": pos_ct,
    "expense_rows_exported": int(len(expenses_out)),
    "output_csv": str(out_path)
}])

# Show a preview of parsed transactions and exported expenses
preview_trans = trans.head(20)
preview_exp = expenses_out.head(20)

print(df_raw.head())

out_path.__str__()
